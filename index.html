```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scrub ↔ Page Sync (with Intro)</title>
  <link rel="stylesheet" href="main.css" />
  <style>
    html,body{overflow:hidden;margin:0;padding:0;background:#000}
    /* keep bars interactive and above video */
    #scrubber, #scrubber2{ pointer-events:auto!important; z-index:10000!important; cursor:ew-resize; touch-action:none; }
    /* overlay should block clicks while visible; when hidden allow events through */
    #screensaver.is-visible{ pointer-events:auto; }
    #screensaver:not(.is-visible){ pointer-events:none; }

    /* === Minimal overrides you asked for === */
    /* make both hitboxes a bit longer and invisible (still usable) */
    :root { --bar-min: 360px; --bar-vw: 58vw; --bar-max: 960px; }
    #scrubber, #scrubber2 {
      width: clamp(var(--bar-min), var(--bar-vw), var(--bar-max)) !important;
      background: transparent !important;
      box-shadow: none !important;
    }
    #scrubber .scrubber__fill, #scrubber2 .scrubber__fill,
    #scrubber .scrubber__hint, #scrubber2 .scrubber__hint { display: none !important; }
  </style>
</head>
<body>
  <!-- MAIN VIDEO -->
  <video id="v0" playsinline muted preload="auto">
    <source src="fingers.mp4" type="video/mp4" />
  </video>

  <!-- Big invisible scrub bar (coarse) -->
  <div id="scrubber" role="slider" aria-label="fine scrub" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div class="scrubber__fill" aria-hidden="true"></div>
    <div class="scrubber__hint" aria-hidden="true">scrub</div>
  </div>

  <!-- Small visible red scrub bar (fine) -->
  <div id="scrubber2" role="slider" aria-label="coarse scrub" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div class="scrubber__fill" aria-hidden="true"></div>
    <div class="scrubber__hint" aria-hidden="true">coarse</div>
  </div>

  <!-- SCREEN SAVER / INTRO OVERLAY (VISIBLE ON LOAD) -->
  <div id="screensaver" class="is-visible" aria-hidden="false">
    <video id="ssv1" playsinline muted preload="auto" autoplay loop>
      <source src="screensaver.mp4" type="video/mp4" />
    </video>
    <video id="ssv2" playsinline muted preload="auto">
      <source src="intro.mp4" type="video/mp4" />
    </video>
  </div>

  <script>
    /************** Config **************/
    const PLAY_START = 0;
    const PLAY_END   = null;   // null = full duration
    const SNAP_TO_FRAMES = false;
    const FPS = 30;

    // === Minimal smoothing knob (new) ===
    const USE_SMOOTHING = true;   // turn off to revert to your original instant seeks
    const SMOOTH_TAU_MS = 140;    // lower = snappier, higher = smoother

    // throttle messages to Wix (ms)
    const SEND_INTERVAL_MS = 50; // ~20 msgs/sec

    // screensaver accel
    const SCREENSAVER_ACCEL = 6.0;

    /************** Elements **************/
    const vid = document.getElementById('v0');
    const barFine   = document.getElementById('scrubber');
    const barCoarse = document.getElementById('scrubber2');
    const fillFine   = barFine.querySelector('.scrubber__fill');
    const fillCoarse = barCoarse.querySelector('.scrubber__fill');

    const overlay = document.getElementById('screensaver');
    const v1 = document.getElementById('ssv1'); // screensaver loop
    const v2 = document.getElementById('ssv2'); // intro

    /************** State **************/
    let playStart = PLAY_START;
    let playEnd   = PLAY_END;     // becomes duration after metadata
    let lastSentAt = 0;
    let allowSync = false;        // parent can react to scrubValue only after intro
    let applyingFromParent = false; // prevent echo on parent→child updates

    const clamp01 = v => Math.max(0, Math.min(1, Number(v)||0));

    /************** Minimal smoother (add-only) **************/
    const __smooth = { target: 0, display: 0, last: 0, raf: 0 };
    function smoothSeek(t){
      if (!USE_SMOOTHING) { vid.currentTime = t; return; }
      __smooth.target = t;
      if (!__smooth.raf) {
        __smooth.display = vid.currentTime || 0;
        __smooth.last = performance.now();
        const step = (now)=>{
          const dt = Math.max(0, now - __smooth.last); __smooth.last = now;
          const alpha = 1 - Math.exp(-dt / SMOOTH_TAU_MS);
          __smooth.display += ( __smooth.target - __smooth.display ) * alpha;
          let tApply = SNAP_TO_FRAMES && FPS>0 ? Math.round(__smooth.display*FPS)/FPS : __smooth.display;
          if (Math.abs((vid.currentTime||0) - tApply) > (SNAP_TO_FRAMES? (0.45/FPS) : 0.01)) {
            try { if (typeof vid.fastSeek === 'function') vid.fastSeek(tApply); else vid.currentTime = tApply; }
            catch(_) { vid.currentTime = tApply; }
          }
          __smooth.raf = requestAnimationFrame(step);
        };
        __smooth.raf = requestAnimationFrame(step);
      }
    }

    /************** Messaging helpers **************/
    function sendToParent(obj){
      try { parent.postMessage(JSON.stringify(obj), '*'); }
      catch(_) { try { parent.postMessage(obj, '*'); } catch(_) {} }
    }
    function parseMsg(d){ if (typeof d === 'string') { try { return JSON.parse(d); } catch { return {}; } } return d || {}; }

    /************** Core mapping **************/
    function ratioToTime(r){
      if (!isFinite(vid.duration) || vid.duration <= 0) return 0;
      const start = Math.max(0, Math.min(playStart, vid.duration));
      const end   = (playEnd == null) ? vid.duration : Math.min(playEnd, vid.duration);
      const span  = Math.max(0, end - start);
      let t = start + clamp01(r) * span;
      if (SNAP_TO_FRAMES && FPS > 0) t = Math.round(t * FPS) / FPS;
      return t;
    }

    function setByRatio(r, {fromParent=false} = {}){
      if (!isFinite(vid.duration) || vid.duration <= 0) return;

      // ▼ CHANGED: use smoother instead of instant seek
      const t = ratioToTime(r);
      smoothSeek(t);

      // p = 0..1 progress within active window
      const endForP = (playEnd==null ? (vid.duration||1) : playEnd);
      const p = clamp01((t - (playStart || 0)) / ((endForP) - (playStart||0) || 1));

      // Update fills
      if (fillFine)   fillFine.style.width   = (p*100).toFixed(3) + '%';
      if (fillCoarse) fillCoarse.style.width = (p*100).toFixed(3) + '%';
      barFine.setAttribute('aria-valuenow',   Math.round(p*100));
      barCoarse.setAttribute('aria-valuenow', Math.round(p*100));

      // Send to Wix (only after intro), and not if this came from Wix
      if (!fromParent && allowSync) {
        const now = performance.now();
        if (now - lastSentAt >= SEND_INTERVAL_MS) {
          lastSentAt = now;
          sendToParent({ type:'scrubValue', value:p }); // 0..1 precise
        }
      }
    }

    /************** Hover/drag wiring (no click required) **************/
    function ratioFromClientX(root, x){ const rect = root.getBoundingClientRect(); const dx = Math.min(Math.max(0, x - rect.left), rect.width); return rect.width ? (dx / rect.width) : 0; }
    function inside(root, x, y){ const r = root.getBoundingClientRect(); return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom; }

    [barFine, barCoarse].forEach(root=>{
      root.addEventListener('pointerenter', e => setByRatio(ratioFromClientX(root, e.clientX)));
      root.addEventListener('mouseenter',   e => setByRatio(ratioFromClientX(root, e.clientX)));
    });

    function onMove(e){
      const { clientX:x, clientY:y } = e;
      if (inside(barFine, x, y))   { setByRatio(ratioFromClientX(barFine,   x)); return; }
      if (inside(barCoarse, x, y)) { setByRatio(ratioFromClientX(barCoarse, x)); return; }
    }
    addEventListener('mousemove', onMove, { passive:true });
    addEventListener('pointermove', onMove, { passive:true });

    [barFine, barCoarse].forEach(root=>{
      let dragging = false;
      root.addEventListener('pointerdown', e=>{ dragging=true; root.setPointerCapture?.(e.pointerId); setByRatio(ratioFromClientX(root, e.clientX)); });
      root.addEventListener('pointermove', e=>{ if(dragging) setByRatio(ratioFromClientX(root, e.clientX)); });
      root.addEventListener('pointerup',   ()=> dragging=false);
      root.addEventListener('pointercancel',()=> dragging=false);
    });

    /************** Metadata: set window **************/
    vid.addEventListener('loadedmetadata', ()=>{
      const dur = isFinite(vid.duration) ? vid.duration : 0;
      if (dur > 0) {
        playStart = Math.max(0, Math.min(PLAY_START, dur));
        playEnd   = (PLAY_END == null) ? dur : Math.max(playStart, Math.min(PLAY_END, dur));
      }
      setByRatio( (vid.currentTime && dur) ? (vid.currentTime / dur) : 0 );
    });

    /************** Keep fills aligned if video changes otherwise **************/
    function updateFillsFromVideo(){
      if (!vid.duration) return;
      const p = clamp01( vid.currentTime / (vid.duration || 1) );
      if (fillFine)   fillFine.style.width   = (p*100).toFixed(3)+'%';
      if (fillCoarse) fillCoarse.style.width = (p*100).toFixed(3)+'%';
      barFine.setAttribute('aria-valuenow', Math.round(p*100));
      barCoarse.setAttribute('aria-valuenow', Math.round(p*100));
    }
    ['timeupdate','seeking','seeked','play','pause'].forEach(ev=>{
      vid.addEventListener(ev, updateFillsFromVideo);
    });

    /************** Parent → Child: receive page scroll as 0..1 **************/
    addEventListener('message', (evt) => {
      const msg = parseMsg(evt.data);
      if (msg.type === 'scrollValue') {
        const p = clamp01(Number(msg.value) || 0);
        applyingFromParent = true;
        setByRatio(p, {fromParent:true});
        setTimeout(()=>{ applyingFromParent = false; }, SEND_INTERVAL_MS);
      }
    });

    /************** Overlay / Intro logic (VISIBLE) **************/
    let accelerating = false;

    function showOverlay(){
      overlay.classList.add('is-visible');
      overlay.setAttribute('aria-hidden','false');
      overlay.classList.remove('mode-intro');
      try { v2.pause(); v2.currentTime = 0; } catch(_) {}
      try { v1.pause(); } catch(_) {}
      v1.playbackRate = 1;
      v1.loop = true;
      try { v1.play().catch(()=>{}); } catch(_) {}

      allowSync = false; // parent should ignore scrub until intro done
      sendToParent({ type: 'lockScroll', value: true });
    }
    function hideOverlay(){
      overlay.classList.remove('is-visible');
      overlay.setAttribute('aria-hidden','true');
      overlay.classList.remove('mode-intro');
      try { v1.pause(); } catch(_) {}
      try { v2.pause(); } catch(_) {}
      allowSync = true;
      sendToParent({ type: 'lockScroll', value: false });
    }
    function accelerateAndFinish(){
      if (!overlay.classList.contains('is-visible')) return;
      if (accelerating) return;
      accelerating = true;
      v1.loop = false;
      v1.playbackRate = SCREENSAVER_ACCEL;
      try { v1.play().catch(()=>{}); } catch(_) {}
    }

    v1.addEventListener('ended', ()=>{
      if (!overlay.classList.contains('is-visible')) return;
      overlay.classList.add('mode-intro');
      try { v2.play().catch(()=>{}); } catch(_) {}
    });

    v2.addEventListener('ended', ()=>{ hideOverlay(); });

    ['pointerdown','click','touchstart','keydown','wheel'].forEach(ev=>{
      overlay.addEventListener(ev, accelerateAndFinish, { passive:true });
    });

    showOverlay();
  </script>
</body>
</html>
```
