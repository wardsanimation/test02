<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll â†’ Video with Dual Scrub Bars</title>
  <link rel="stylesheet" href="main.css" />
</head>
<body>
  <div id="set-height"></div>

  <video id="v0" playsinline muted preload>
    <source src="fingers.mp4" type="video/mp4" />
  </video>

  <!-- Big invisible scrub bar (coarse control) -->
  <div id="scrubber2" role="slider" aria-label="Scroll scrubber (coarse)" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div class="scrubber__fill" aria-hidden="true"></div>
    <div class="scrubber__hint" aria-hidden="true">coarse</div>
  </div>

  <!-- Small visible scrub bar (fine control) -->
  <div id="scrubber" role="slider" aria-label="Scroll scrubber" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div class="scrubber__fill" aria-hidden="true"></div>
    <div class="scrubber__hint" aria-hidden="true">scrub</div>
  </div>

  <!-- Screen saver overlay -->
  <div id="screensaver" aria-hidden="true">
    <video id="ssv1" playsinline muted preload="auto" autoplay loop>
      <source src="screensaver.mp4" type="video/mp4" />
    </video>
    <video id="ssv2" playsinline muted preload="auto">
      <source src="intro.mp4" type="video/mp4" />
    </video>
  </div>

  <script>
    // ===== Config (your values kept) =====
    const PLAY_START = 0;
    const PLAY_END   = 17;
    const SNAP_TO_FRAMES   = true;
    const FPS              = 30;
    const USE_FASTSEEK     = true;
    const SCREENSAVER_ACCEL = 6.0;

    // Elements
    const track = document.getElementById('set-height');
    const vid = document.getElementById('v0');

    // Playback window
    let playStart = PLAY_START;
    let playEnd   = PLAY_END;

    // ====== Progress-based control ======
    let progress = 0;           // 0..1
    let allowSync = false;      // becomes true after intro finishes

    function clamp01(v){ return Math.max(0, Math.min(1, v || 0)); }

    function applyVideoFromProgress(p){
      if (!isFinite(vid.duration) || vid.duration <= 0) return;
      const start = Math.min(playStart, vid.duration);
      const end   = Math.min(playEnd,   vid.duration);
      let t = start + p * Math.max(0, end - start);
      if (SNAP_TO_FRAMES && FPS > 0) t = Math.round(t * FPS) / FPS;
      if (USE_FASTSEEK && typeof vid.fastSeek === 'function') {
        try { vid.fastSeek(t); } catch(_) { vid.currentTime = t; }
      } else {
        vid.currentTime = t;
      }
    }

    function updateScrubFills(){
      const f1 = document.querySelector('#scrubber .scrubber__fill');
      const f2 = document.querySelector('#scrubber2 .scrubber__fill');
      if (f1) f1.style.width = (progress * 100).toFixed(3) + '%';
      if (f2) f2.style.width = (progress * 100).toFixed(3) + '%';
      const s1 = document.getElementById('scrubber');
      const s2 = document.getElementById('scrubber2');
      if (s1) s1.setAttribute('aria-valuenow', Math.round(progress * 100));
      if (s2) s2.setAttribute('aria-valuenow', Math.round(progress * 100));
    }

    // Throttled post to Wix parent (only after intro ends)
    let lastSent = 0;
    function sendProgressToParent(p){
      const now = performance.now();
      if (now - lastSent < 80) return; // throttle
      lastSent = now;
      parent.postMessage({ type: 'videoProgress', value: clamp01(p) }, '*');
    }

    // âœ… Always update video; only message Wix if allowSync is true
    function setProgress(p){
      progress = clamp01(p);
      applyVideoFromProgress(progress);   // ALWAYS seek the video
      updateScrubFills();
      if (allowSync) {                    // Wix sync gated until intro finishes
        sendProgressToParent(progress);
      }
    }

    // Metadata
    vid.addEventListener('loadedmetadata', () => {
      const dur = isFinite(vid.duration) ? vid.duration : 0;
      if (dur > 0) {
        playStart = Math.max(0, Math.min(PLAY_START, dur));
        playEnd   = Math.max(playStart, Math.min(PLAY_END, dur));
      }
      setProgress(progress);
    });

    // If video moves, update
    function computeProgressFromVideo() {
      if (!vid.duration) return progress;
      const start = Math.min(playStart, vid.duration);
      const end   = Math.min(playEnd,   vid.duration);
      const span  = Math.max(0.0001, end - start);
      return (vid.currentTime - start) / span;
    }
    vid.addEventListener('timeupdate', () => { setProgress(computeProgressFromVideo()); });
    ['seeking','seeked','play','pause'].forEach(ev => {
      vid.addEventListener(ev, () => { setProgress(computeProgressFromVideo()); });
    });

    // ===== Scrub bars (hover + drag) =====
    (function initScrubbers() {
      function wire(rootId) {
        const root = document.getElementById(rootId);
        if (!root) return;
        const fill = root.querySelector('.scrubber__fill');

        function ratioFromClientX(x) {
          const rect = root.getBoundingClientRect();
          const dx = Math.min(Math.max(0, x - rect.left), rect.width);
          return rect.width ? dx / rect.width : 0;
        }

        // Hover-to-scrub (no click required)
        let raf = 0;
        root.addEventListener('pointermove', (e) => {
          if (raf) return;
          raf = requestAnimationFrame(() => {
            raf = 0;
            setProgress(ratioFromClientX(e.clientX));
          });
        }, { passive: true });

        // Drag-to-scrub (for touch & mouse)
        let dragging = false;
        root.addEventListener('pointerdown', (e) => {
          dragging = true;
          root.setPointerCapture?.(e.pointerId);
          setProgress(ratioFromClientX(e.clientX));
        });
        root.addEventListener('pointermove', (e) => {
          if (!dragging) return;
          setProgress(ratioFromClientX(e.clientX));
        });
        root.addEventListener('pointerup',   () => { dragging = false; });
        root.addEventListener('pointercancel', () => { dragging = false; });

        // Keyboard
        root.addEventListener('keydown', (e) => {
          let r = progress;
          const step = 0.05;
          if (e.key === 'ArrowRight' || e.key === 'ArrowUp')   { r = Math.min(1, r + step); setProgress(r); e.preventDefault(); }
          if (e.key === 'ArrowLeft'  || e.key === 'ArrowDown') { r = Math.max(0, r - step); setProgress(r); e.preventDefault(); }
          if (e.key === 'Home') { setProgress(0); e.preventDefault(); }
          if (e.key === 'End')  { setProgress(1); e.preventDefault(); }
        });

        // Keep fill width in sync on resize
        window.addEventListener('resize', () => {
          if (fill) fill.style.width = (progress * 100).toFixed(3) + '%';
        });
      }
      wire('scrubber');
      wire('scrubber2');
    })();

    // ===== Screensaver / Intro gating =====
    (function initScreensaver(){
      const overlay = document.getElementById('screensaver');
      const v1 = document.getElementById('ssv1');
      const v2 = document.getElementById('ssv2');

      let accelerating = false;

      function showOverlay(){
        overlay.classList.add('is-visible');
        overlay.classList.remove('mode-intro');
        try { v2.pause(); v2.currentTime = 0; } catch(_) {}
        try { v1.pause(); } catch(_) {}
        v1.playbackRate = 1;
        v1.loop = true;
        try { v1.play().catch(()=>{}); } catch(_) {}
        accelerating = false;
        allowSync = false; // block Wix sync while overlay visible
      }
      function hideOverlay(){
        overlay.classList.remove('is-visible');
        overlay.classList.remove('mode-intro');
        try { v1.pause(); } catch(_) {}
        try { v2.pause(); } catch(_) {}
      }

      function accelerateAndFinish(){
        if (!overlay.classList.contains('is-visible')) return;
        if (accelerating) return;
        accelerating = true;
        v1.loop = false;
        v1.playbackRate = SCREENSAVER_ACCEL;
        try { v1.play().catch(()=>{}); } catch(_) {}
      }

      v1.addEventListener('ended', () => {
        if (!overlay.classList.contains('is-visible')) return;
        if (accelerating) {
          overlay.classList.add('mode-intro');
          v2.playbackRate = 1.0;
          try { v2.play().catch(()=>{}); } catch(_) {}
        }
      });

      // ðŸ‘‰ Enable Wix sync ONLY after the intro ends
      v2.addEventListener('ended', () => {
        hideOverlay();
        allowSync = true; // now page scroll will follow progress
      });

      ['pointerdown','click','touchstart','keydown','wheel'].forEach(ev => {
        overlay.addEventListener(ev, accelerateAndFinish, { passive: true });
      });

      // Start with overlay visible
      showOverlay();
    })();
  </script>

  <!-- Ensure no inner scrollbars in the iframe -->
  <style>
    html, body { overflow: hidden; margin: 0; padding: 0; }
  </style>
</body>
</html>
