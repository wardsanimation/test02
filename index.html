<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll â†’ Video with Dual Scrub Bars</title>
  <link rel="stylesheet" href="main.css" />
</head>
<body>
  <div id="set-height"></div>

  <video id="v0" playsinline muted preload>
    <source src="fingers.mp4" type="video/mp4" />
  </video>

  <!-- Big invisible scrub bar (coarse control) -->
  <div id="scrubber2" role="slider" aria-label="Scroll scrubber (coarse)" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div class="scrubber__fill" aria-hidden="true"></div>
    <div class="scrubber__hint" aria-hidden="true">coarse</div>
  </div>

  <!-- Small visible scrub bar (fine control) -->
  <div id="scrubber" role="slider" aria-label="Scroll scrubber" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div class="scrubber__fill" aria-hidden="true"></div>
    <div class="scrubber__hint" aria-hidden="true">scrub</div>
  </div>

  <!-- Screen saver overlay (starts visible on load) -->
  <div id="screensaver" aria-hidden="true">
    <video id="ssv1" playsinline muted preload="auto" autoplay loop>
      <source src="screensaver.mp4" type="video/mp4" />
    </video>
    <video id="ssv2" playsinline muted preload="auto">
      <source src="intro.mp4" type="video/mp4" />
    </video>
  </div>

  <script>
    // ===== Config (kept your values) =====
    const SCROLL_PX_PER_SEC = 600; // (kept) not used now, but left in case you re-enable inner scroll
    const PLAY_START = 0;          // seconds
    const PLAY_END   = 17;         // seconds

    // ==== Smoothness & seeking knobs (kept) ====
    const SNAP_TO_FRAMES   = true; // snap seeks to exact frame boundaries
    const FPS              = 30;   // set to your source fps (e.g., 25 or 30)
    const USE_FASTSEEK     = true; // prefer HTMLMediaElement.fastSeek when available
    const SMOOTH_TAU_MS    = 220;  // kept (not needed in progress mode, but left)

    // Screensaver accel factor on interaction (kept)
    const SCREENSAVER_ACCEL = 6.0;

    // Elements
    const track = document.getElementById('set-height');
    const vid = document.getElementById('v0');

    // Playback window
    let playStart = PLAY_START;
    let playEnd   = PLAY_END;

    // ====== NEW: Progress-based control (no inner scrolling) ======
    let progress = 0;           // 0..1 overall progress
    let allowSync = false;      // becomes true after intro finishes

    function clamp01(v){ return Math.max(0, Math.min(1, v || 0)); }

    function applyVideoFromProgress(p){
      if (!isFinite(vid.duration) || vid.duration <= 0) return;
      const start = Math.min(playStart, vid.duration);
      const end   = Math.min(playEnd,   vid.duration);
      let t = start + p * Math.max(0, end - start);
      if (SNAP_TO_FRAMES && FPS > 0) t = Math.round(t * FPS) / FPS;
      if (USE_FASTSEEK && typeof vid.fastSeek === 'function') {
        try { vid.fastSeek(t); } catch(_) { vid.currentTime = t; }
      } else {
        vid.currentTime = t;
      }
    }

    function updateScrubFills(){
      const f1 = document.querySelector('#scrubber .scrubber__fill');
      const f2 = document.querySelector('#scrubber2 .scrubber__fill');
      if (f1) f1.style.width = (progress * 100).toFixed(3) + '%';
      if (f2) f2.style.width = (progress * 100).toFixed(3) + '%';
      // aria value for accessibility
      const s1 = document.getElementById('scrubber');
      const s2 = document.getElementById('scrubber2');
      if (s1) s1.setAttribute('aria-valuenow', Math.round(progress * 100));
      if (s2) s2.setAttribute('aria-valuenow', Math.round(progress * 100));
    }

    // Throttled postMessage to parent (Wix)
    let lastSent = 0;
    function sendProgressToParent(p){
      if (!allowSync) return;
      const now = performance.now();
      if (now - lastSent < 80) return; // ~12â€“15 msgs/sec is plenty
      lastSent = now;
      parent.postMessage({ type: 'videoProgress', value: clamp01(p) }, '*');
    }

    function setProgress(p){
      progress = clamp01(p);
      applyVideoFromProgress(progress);
      updateScrubFills();
      sendProgressToParent(progress);
    }

    // Keep your original metadata handling
    function updateScrollTrack() {
      const seconds = Math.max(0.1, (playEnd - playStart) || (PLAY_END - PLAY_START) || 1);
      track.style.height = Math.round(seconds * SCROLL_PX_PER_SEC) + 'px';
    }
    document.addEventListener('DOMContentLoaded', updateScrollTrack);
    vid.addEventListener('loadedmetadata', () => {
      const dur = isFinite(vid.duration) ? vid.duration : 0;
      if (dur > 0) {
        playStart = Math.max(0, Math.min(PLAY_START, dur));
        playEnd   = Math.max(playStart, Math.min(PLAY_END, dur));
      }
      updateScrollTrack();
      // ensure video matches current progress
      setProgress(progress);
    });

    // If video moves (e.g., play, seek), broadcast new progress
    function computeProgressFromVideo() {
      if (!vid.duration) return progress;
      const start = Math.min(playStart, vid.duration);
      const end   = Math.min(playEnd,   vid.duration);
      const span  = Math.max(0.0001, end - start);
      return (vid.currentTime - start) / span;
    }
    vid.addEventListener('timeupdate', () => { setProgress(computeProgressFromVideo()); });
    ['seeking','seeked','play','pause'].forEach(ev => {
      vid.addEventListener(ev, () => { setProgress(computeProgressFromVideo()); });
    });

    // ===== Scrub bars (now set progress directly; no inner scroll) =====
    (function initScrubbers() {
      function wire(rootId) {
        const root = document.getElementById(rootId);
        if (!root) return;
        const fill = root.querySelector('.scrubber__fill');

        function ratioFromClientX(x) {
          const rect = root.getBoundingClientRect();
          const dx = Math.min(Math.max(0, x - rect.left), rect.width);
          return rect.width ? dx / rect.width : 0;
        }

        function updateFill() {
          if (fill) fill.style.width = (progress * 100).toFixed(3) + '%';
          root.setAttribute('aria-valuenow', Math.round(progress * 100));
        }

        let dragging = false;
        root.addEventListener('pointerdown', (e) => {
          dragging = true;
          root.setPointerCapture(e.pointerId);
          setProgress(ratioFromClientX(e.clientX));
        });
        root.addEventListener('pointermove', (e) => {
          if (!dragging) return;
          setProgress(ratioFromClientX(e.clientX));
        });
        root.addEventListener('pointerup',   () => { dragging = false; });
        root.addEventListener('pointercancel', () => { dragging = false; });

        root.addEventListener('keydown', (e) => {
          let r = progress;
          const step = 0.05;
          if (e.key === 'ArrowRight' || e.key === 'ArrowUp')   { r = Math.min(1, r + step); setProgress(r); e.preventDefault(); }
          if (e.key === 'ArrowLeft'  || e.key === 'ArrowDown') { r = Math.max(0, r - step); setProgress(r); e.preventDefault(); }
          if (e.key === 'Home') { setProgress(0); e.preventDefault(); }
          if (e.key === 'End')  { setProgress(1); e.preventDefault(); }
        });

        window.addEventListener('resize', updateFill);
        updateFill();
      }
      wire('scrubber');
      wire('scrubber2');
    })();

    // ===== Screen saver (idle after 1 minute; kept logic) =====
    (function initScreensaver(){
      const IDLE_MS = 60_000; // re-show after idle
      const overlay = document.getElementById('screensaver');
      const v1 = document.getElementById('ssv1'); // screensaver
      const v2 = document.getElementById('ssv2'); // short intro

      let accelerating = false;     // true after first interaction while overlay visible
      let firstSequenceDone = false;
      let idleTimer = null;

      function showOverlay(mode){
        overlay.classList.add('is-visible');
        overlay.classList.remove('mode-intro');
        // reset videos
        try { v2.pause(); v2.currentTime = 0; } catch(_) {}
        try { v1.pause(); } catch(_) {}
        v1.playbackRate = 1;          // reset normal speed
        v1.loop = true;                // loop until user interacts
        try { v1.play().catch(()=>{}); } catch(_) {}
        accelerating = false;
        allowSync = false;             // ensure sync is OFF while overlay is up
      }
      function hideOverlay(){
        if (!overlay.classList.contains('is-visible')) return;
        overlay.classList.remove('is-visible');
        overlay.classList.remove('mode-intro');
        try { v1.pause(); } catch(_) {}
        try { v2.pause(); } catch(_) {}
      }
      function scheduleIdle(){
        clearTimeout(idleTimer);
        idleTimer = setTimeout(() => showOverlay('idle'), IDLE_MS);
      }

      function accelerateAndFinish(){
        if (!overlay.classList.contains('is-visible')) return;
        if (accelerating) return; // already accelerating
        accelerating = true;
        // Stop looping and speed up to finish
        v1.loop = false;
        v1.playbackRate = SCREENSAVER_ACCEL;
        try { v1.play().catch(()=>{}); } catch(_) {}
      }

      // When v1 finishes (after accelerate), play v2; then hide
      v1.addEventListener('ended', () => {
        if (!overlay.classList.contains('is-visible')) return;
        if (accelerating) {
          overlay.classList.add('mode-intro');
          v2.playbackRate = 1.0;
          try { v2.play().catch(()=>{}); } catch(_) {}
        } else {
          // If it somehow ended without accelerate, restart (loop safeguard)
          if (!v1.loop) { v1.loop = true; }
          try { v1.play().catch(()=>{}); } catch(_) {}
        }
      });

      // ðŸ‘‰ Enable syncing only when the intro finishes
      v2.addEventListener('ended', () => {
        firstSequenceDone = true;
        hideOverlay();
        allowSync = true;     // <-- sync now allowed
        scheduleIdle();
      });

      // Any interaction ON the overlay triggers accelerate
      ['pointerdown','click','touchstart','keydown','wheel'].forEach(ev => {
        overlay.addEventListener(ev, accelerateAndFinish, { passive: true });
      });

      // Background activity while overlay hidden only extends idle timer
      ['pointermove','pointerdown','touchstart','keydown','wheel','scroll'].forEach(ev => {
        window.addEventListener(ev, () => { if (!overlay.classList.contains('is-visible')) scheduleIdle(); }, { passive: true });
      });

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) { hideOverlay(); clearTimeout(idleTimer); }
        else { if (firstSequenceDone) scheduleIdle(); }
      });

      // Start with overlay visible and v1 playing
      showOverlay('initial');
    })();
  </script>

  <!-- (Kept) Messaging helper consolidated above via sendProgressToParent() -->
  <style>
    /* ensure no inner scrollbars (important for Wix iFrame) */
    html, body { overflow: hidden; }
  </style>
</body>
</html>
